generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  
  // Location
  zipcode   String?
  
  // Profile - Development & Skills
  strengths        String[]
  weaknesses       String[]
  passions         String[]
  developmentPath  String[]
  
  // Email Verification
  emailVerified    Boolean  @default(false)
  emailVerifiedAt  DateTime?
  verificationToken String?  @unique

  // Password Reset
  passwordResetToken   String?   @unique
  passwordResetExpires DateTime?
  
  // Payment
  stripeCustomerId      String?  @unique
  stripeSubscriptionId  String?  @unique
  subscriptionStatus    SubscriptionStatus @default(INCOMPLETE)
  subscriptionStartedAt DateTime?
  
  // Profile Completion
  profileCompleted Boolean @default(false)

  // Community Guidelines Acceptance
  guidelinesAcceptedAt DateTime?
  guidelinesVersion    Int?

  // Terms of Service & Privacy Policy Acceptance
  tosAcceptedAt DateTime?
  tosVersion    Int?

  // Platform Admin
  isAdmin Boolean @default(false)

  // Notification Settings
  emailNotificationFrequency EmailFrequency @default(DAILY)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  memberships             Member[]
  sessions                Session[]
  bandsCreated            Band[] @relation("BandCreator")
  notifications           Notification[]
  notificationPreferences NotificationPreference[]
  proposalsCreated        Proposal[] @relation("ProposalCreator")
  votes                   Vote[]
  projectsCreated         Project[] @relation("ProjectCreator")
  projectsLed             Project[] @relation("ProjectLead")
  tasksCreated            Task[] @relation("TaskCreator")
  tasksAssigned           Task[] @relation("TaskAssignee")
  tasksVerified           Task[] @relation("TaskVerifier")
  filesUploaded           File[] @relation("FilesUploaded")

  commentsAuthored        Comment[] @relation("CommentsAuthored")
  reactionsGiven          Reaction[] @relation("ReactionsGiven")
  mentionsReceived        Mention[] @relation("MentionsReceived")
  checklistItemsCompleted ChecklistItem[] @relation("ChecklistItemsCompleted")
  checklistItemsAssigned  ChecklistItem[] @relation("ChecklistItemsAssigned")
  pendingInvitesCreated   PendingInvite[] @relation("PendingInvitesCreated")
  bandsAsBillingOwner     Band[] @relation("BandBillingOwner")
  eventsCreated           Event[] @relation("EventsCreated")
  eventRSVPs              EventRSVP[] @relation("EventRSVPs")
  eventAttendances        EventAttendance[] @relation("EventAttendances")
  attendanceMarked        EventAttendance[] @relation("AttendanceMarker")
}

enum SubscriptionStatus {
  INCOMPLETE
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
}

enum EmailFrequency {
  REAL_TIME
  HOURLY
  DAILY
  WEEKLY
  NEVER
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id              String   @id @default(cuid())
  userId          String
  type            NotificationType
  title           String
  message         String?
  actionUrl       String?
  priority        NotificationPriority @default(MEDIUM)
  isRead          Boolean  @default(false)
  isArchived      Boolean  @default(false)
  emailedAt       DateTime?
  readAt          DateTime?
  archivedAt      DateTime?
  
  metadata        Json?
  
  relatedId       String?
  relatedType     String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@index([userId, type])
  @@index([emailedAt])
}

enum NotificationType {
  // Band invitations
  BAND_INVITE_RECEIVED
  BAND_INVITE_ACCEPTED
  BAND_INVITE_DECLINED
  
  // Band applications
  BAND_APPLICATION_RECEIVED
  BAND_APPLICATION_APPROVED
  BAND_APPLICATION_REJECTED
  
  // Band membership
  BAND_MEMBER_JOINED
  BAND_MEMBER_LEFT
  BAND_STATUS_CHANGED
  
  // Band updates
  BAND_DETAILS_UPDATED
  
  // Proposals
  PROPOSAL_CREATED
  PROPOSAL_VOTE_NEEDED
  PROPOSAL_APPROVED
  PROPOSAL_REJECTED
  PROPOSAL_CLOSED
  
  // Projects
  PROJECT_CREATED
  PROJECT_STATUS_CHANGED
  
  // Tasks
  TASK_CREATED
  TASK_ASSIGNED
  TASK_STATUS_CHANGED
  TASK_COMPLETED
  TASK_VERIFICATION_NEEDED
  TASK_VERIFIED
  TASK_REJECTED

  // Billing
  BILLING_PAYMENT_REQUIRED
  BILLING_PAYMENT_SUCCEEDED
  BILLING_PAYMENT_FAILED
  BILLING_GRACE_PERIOD_WARNING
  BILLING_BAND_DEACTIVATED
  BILLING_OWNER_LEFT
  BILLING_OWNER_CLAIMED
  BILLING_SUBSCRIPTION_UPGRADED
  BILLING_SUBSCRIPTION_DOWNGRADED

  // Events
  EVENT_CREATED
  EVENT_UPDATED
  EVENT_CANCELLED
  EVENT_REMINDER
  EVENT_RSVP_RECEIVED
  EVENT_ATTENDANCE_MARKED
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model NotificationTemplate {
  id              String @id @default(cuid())
  type            NotificationType @unique
  title           String
  message         String
  emailSubject    String
  emailBody       String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model NotificationPreference {
  id              String @id @default(cuid())
  userId          String
  type            NotificationType
  inApp           Boolean @default(true)
  email           Boolean @default(true)
  
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, type])
  @@index([userId])
}

// ============================================
// BAND
// ============================================

model Band {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique

  // Core Information
  description String @db.Text
  mission     String @db.Text
  values      String[]

  // Location
  zipcode     String?

  // Matching
  skillsLookingFor     String[]
  whatMembersWillLearn String[]

  // Visual
  imageUrl    String?

  // Status
  status      BandStatus @default(INACTIVE)

  // Billing
  billingOwnerId        String?
  stripeCustomerId      String?   @unique
  stripeSubscriptionId  String?   @unique
  stripePriceId         String?
  billingStatus         BillingStatus @default(NONE)
  billingCycleStart     DateTime?
  paymentFailedAt       DateTime?
  gracePeriodEndsAt     DateTime?

  // Membership Configuration
  membershipRequirements String @db.Text
  whoCanApprove         MemberRole[]

  // Voting Configuration
  votingMethod          VotingMethod @default(SIMPLE_MAJORITY)
  votingPeriodDays      Int @default(7)
  whoCanCreateProposals MemberRole[] @default([FOUNDER, GOVERNOR, MODERATOR, CONDUCTOR])

  // Role Management Configuration
  whoCanChangeRoles     MemberRole[] @default([FOUNDER])

  // Metadata
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  createdBy User @relation("BandCreator", fields: [createdById], references: [id])
  billingOwner User? @relation("BandBillingOwner", fields: [billingOwnerId], references: [id])
  members   Member[]
  proposals Proposal[]
  projects  Project[]
  tasks     Task[]
  events    Event[]
  files     File[]
  comments  Comment[]
  auditLogs AuditLog[]
  pendingInvites PendingInvite[]
  aiUsage   AIUsage[]

  @@index([createdById])
  @@index([status])
  @@index([billingOwnerId])
  @@index([billingStatus])
}

enum BandStatus {
  PENDING    // DEPRECATED - do not use, kept for migration compatibility
  ACTIVE
  INACTIVE
}

enum BillingStatus {
  NONE           // No payment needed yet (< 3 members)
  PENDING        // 3 members reached, awaiting first payment
  ACTIVE         // Subscription active
  PAST_DUE       // Payment failed, in grace period
  INACTIVE       // Grace period expired or subscription cancelled
}

enum VotingMethod {
  SIMPLE_MAJORITY      // >50%
  SUPERMAJORITY_66     // >66%
  SUPERMAJORITY_75     // >75%
  UNANIMOUS            // 100%
}

model Member {
  id        String   @id @default(cuid())
  userId    String
  bandId    String
  role      MemberRole
  status    MemberStatus @default(PENDING)
  
  invitedBy String?
  notes     String? @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  band Band @relation(fields: [bandId], references: [id], onDelete: Cascade)

  @@unique([userId, bandId])
  @@index([bandId])
  @@index([userId])
  @@index([status])
}

enum MemberRole {
  FOUNDER
  GOVERNOR
  MODERATOR
  CONDUCTOR
  VOTING_MEMBER
  OBSERVER
}

enum MemberStatus {
  INVITED
  PENDING
  ACTIVE
  REJECTED
}

// ============================================
// PROPOSALS
// ============================================

model Proposal {
  id            String   @id @default(cuid())
  bandId        String
  createdById   String
  
  // Core
  title         String
  description   String @db.Text
  
  // Type & Priority
  type          ProposalType @default(GENERAL)
  priority      ProposalPriority @default(MEDIUM)
  
  // Problem & Outcome
  problemStatement    String? @db.Text
  expectedOutcome     String? @db.Text
  risksAndConcerns    String? @db.Text
  
  // Budget
  budgetRequested     Decimal? @db.Decimal(12, 2)
  budgetBreakdown     String? @db.Text
  fundingSource       String?
  
  // Timeline
  proposedStartDate   DateTime?
  proposedEndDate     DateTime?
  milestones          String? @db.Text
  
  // Attachments & Links (legacy - keeping for backwards compatibility)
  attachmentUrls      String[]
  externalLinks       String[]
  
  // Voting
  status        ProposalStatus @default(OPEN)
  votingEndsAt  DateTime
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  closedAt      DateTime?
  
  // AI
  aiValidation  Json?

  // Relations
  band      Band @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdBy User @relation("ProposalCreator", fields: [createdById], references: [id])
  votes     Vote[]
  projects  Project[]
  files     File[]
  comments  Comment[]

  @@index([bandId])
  @@index([createdById])
  @@index([status])
  @@index([votingEndsAt])
  @@index([type])
}

enum ProposalType {
  GENERAL
  BUDGET
  PROJECT
  POLICY
  MEMBERSHIP
}

enum ProposalPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ProposalStatus {
  OPEN
  CLOSED
  APPROVED
  REJECTED
}

model Vote {
  id          String   @id @default(cuid())
  proposalId  String
  userId      String
  
  vote        VoteType
  comment     String? @db.Text
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  proposal Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([proposalId, userId])
  @@index([proposalId])
  @@index([userId])
}

enum VoteType {
  YES
  NO
  ABSTAIN
}

// ============================================
// PROJECTS
// ============================================

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum ProjectPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model Project {
  id          String   @id @default(cuid())
  bandId      String
  proposalId  String
  
  // Core
  name        String
  description String?  @db.Text
  status      ProjectStatus @default(PLANNING)
  priority    ProjectPriority @default(MEDIUM)
  
  // Timeline
  startDate   DateTime?
  targetDate  DateTime?
  completedAt DateTime?
  
  // Budget & Effort
  estimatedBudget Decimal? @db.Decimal(12, 2)
  estimatedHours  Int?
  
  // Deliverables & Success
  deliverables    String?  @db.Text
  successCriteria String?  @db.Text
  
  // Organization
  tags            String[]
  orderIndex      Int      @default(0)
  
  // Dependencies (stored as comma-separated project IDs for simplicity)
  dependsOn       String[]
  
  // Progress tracking
  totalTasks      Int @default(0)
  completedTasks  Int @default(0)
  
  // AI
  aiGenerated     Boolean @default(false)
  aiValidation    Json?
  
  // Assignment
  leadId          String?
  
  // Metadata
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  band      Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  proposal  Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  createdBy User     @relation("ProjectCreator", fields: [createdById], references: [id])
  lead      User?    @relation("ProjectLead", fields: [leadId], references: [id])
  tasks     Task[]
  files     File[]
  comments  Comment[]

  @@index([bandId])
  @@index([proposalId])
  @@index([status])
  @@index([priority])
  @@index([createdById])
  @@index([leadId])
}

// ============================================
// TASKS
// ============================================

enum TaskStatus {
  TODO
  IN_PROGRESS
  IN_REVIEW
  COMPLETED
  BLOCKED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum AssigneeType {
  MEMBER
  BANDINO
  VENDOR
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model Task {
  id          String   @id @default(cuid())
  projectId   String
  bandId      String
  
  // Core
  name        String
  description String?  @db.Text
  status      TaskStatus @default(TODO)
  priority    TaskPriority @default(MEDIUM)
  
  // Assignment
  assigneeId    String?
  assigneeType  AssigneeType @default(MEMBER)
  
  // Timeline
  dueDate     DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  
  // Effort
  estimatedHours Int?
  actualHours    Int?
  estimatedCost  Decimal? @db.Decimal(12, 2)
  actualCost     Decimal? @db.Decimal(12, 2)
  
  // Verification
  requiresVerification Boolean @default(true)
  verificationStatus   VerificationStatus?
  verifiedById         String?
  verifiedAt           DateTime?
  verificationNotes    String? @db.Text
  
  // Proof/Evidence (legacy - keeping for backwards compatibility)
  attachments      String[]
  proofDescription String? @db.Text
  receiptUrls      String[]
  
  // Organization
  tags        String[]
  orderIndex  Int @default(0)
  
  // AI
  aiGenerated   Boolean @default(false)
  aiValidation  Json?
  
  // Metadata
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  project    Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  band       Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdBy  User     @relation("TaskCreator", fields: [createdById], references: [id])
  assignee   User?    @relation("TaskAssignee", fields: [assigneeId], references: [id])
  verifiedBy User?    @relation("TaskVerifier", fields: [verifiedById], references: [id])
  files      File[]
  comments  Comment[]
  checklistItems ChecklistItem[]

  @@index([projectId])
  @@index([bandId])
  @@index([status])
  @@index([priority])
  @@index([assigneeId])
  @@index([createdById])
  @@index([verifiedById])
  @@index([dueDate])
}

// ============================================
// EVENTS
// ============================================

enum EventType {
  ONLINE_MEETING
  IN_PERSON_MEETING
  SOCIAL
  HYBRID
}

enum RSVPStatus {
  GOING
  NOT_GOING
  MAYBE
}

model Event {
  id          String   @id @default(cuid())
  bandId      String
  createdById String

  // Core
  title       String
  description String?  @db.Text
  eventType   EventType

  // Timing
  startTime   DateTime
  endTime     DateTime
  timezone    String   @default("America/New_York")

  // Location (for IN_PERSON_MEETING, SOCIAL, HYBRID)
  location    String?
  address     String?  @db.Text

  // Online meeting (for ONLINE_MEETING, HYBRID)
  meetingUrl  String?
  meetingId   String?
  meetingPassword String?

  // Recurrence (using RRULE format from iCalendar RFC 5545)
  // null = one-time event
  // Example: "FREQ=WEEKLY;BYDAY=MO,WE,FR" or "FREQ=MONTHLY;BYMONTHDAY=15"
  recurrenceRule String?

  // For recurring events, track the series end date (optional)
  recurrenceEndDate DateTime?

  // For exceptions/modifications to recurring events
  // If this is set, this event is an exception to the series
  parentEventId String?
  exceptionDate DateTime?  // The date this exception replaces in the series

  // Cancellation
  isCancelled     Boolean  @default(false)
  cancelledAt     DateTime?
  cancellationNote String?

  // Notes from event (added after meeting)
  meetingNotes    String?  @db.Text

  // Reminders (hours before event)
  reminderHours   Int[]    @default([24, 1])
  lastReminderSentAt DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  band        Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("EventsCreated", fields: [createdById], references: [id])
  parentEvent Event?   @relation("EventExceptions", fields: [parentEventId], references: [id])
  exceptions  Event[]  @relation("EventExceptions")
  rsvps       EventRSVP[]
  attendance  EventAttendance[]
  files       File[]

  @@index([bandId])
  @@index([createdById])
  @@index([startTime])
  @@index([eventType])
  @@index([parentEventId])
  @@index([isCancelled])
}

model EventRSVP {
  id          String   @id @default(cuid())
  eventId     String
  userId      String

  status      RSVPStatus
  note        String?  @db.Text

  // For recurring events, RSVP applies to the series
  // If user needs different response for specific instance, use EventAttendance

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation("EventRSVPs", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
}

model EventAttendance {
  id          String   @id @default(cuid())
  eventId     String
  userId      String

  // For recurring events, track which occurrence this is for
  occurrenceDate DateTime?

  // Attendance status
  attended    Boolean
  arrivedAt   DateTime?
  leftAt      DateTime?

  // Notes about attendance
  notes       String?  @db.Text

  // Who marked attendance (could be the user themselves or a moderator)
  markedById  String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation("EventAttendances", fields: [userId], references: [id], onDelete: Cascade)
  markedBy    User     @relation("AttendanceMarker", fields: [markedById], references: [id])

  @@unique([eventId, userId, occurrenceDate])
  @@index([eventId])
  @@index([userId])
  @@index([occurrenceDate])
  @@index([markedById])
}

// ============================================
// CHECKLIST ITEMS
// ============================================

model ChecklistItem {
  id          String   @id @default(cuid())
  taskId      String
  
  // Content
  description String
  notes       String?  @db.Text
  
  // Assignment
  assigneeId  String?
  dueDate     DateTime?
  
  // Status
  isCompleted   Boolean  @default(false)
  completedById String?
  completedAt   DateTime?
  
  // Order
  orderIndex    Int @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  completedBy User?    @relation("ChecklistItemsCompleted", fields: [completedById], references: [id])
  assignee    User?    @relation("ChecklistItemsAssigned", fields: [assigneeId], references: [id])
  files       File[]

  @@index([taskId])
  @@index([completedById])
  @@index([assigneeId])
}

// ============================================
// FILES
// ============================================

enum FileCategory {
  IMAGE
  DOCUMENT
  RECEIPT
  OTHER
}

model File {
  id            String   @id @default(cuid())
  
  // File info
  filename      String
  originalName  String
  mimeType      String
  size          Int
  category      FileCategory @default(OTHER)
  
  // Storage
  storageKey    String   @unique
  url           String
  
  // Ownership
  uploadedById  String
  
  // Attachments - which entity this file belongs to (only one should be set)
  bandId          String?
  proposalId      String?
  projectId       String?
  taskId          String?
  checklistItemId String?
  eventId         String?
  
  // Metadata
  description   String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  uploadedBy    User     @relation("FilesUploaded", fields: [uploadedById], references: [id])
  band          Band?    @relation(fields: [bandId], references: [id], onDelete: Cascade)
  proposal      Proposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  project       Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  task          Task?    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  checklistItem ChecklistItem? @relation(fields: [checklistItemId], references: [id], onDelete: Cascade)
  event         Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([uploadedById])
  @@index([bandId])
  @@index([proposalId])
  @@index([projectId])
  @@index([taskId])
  @@index([checklistItemId])
  @@index([eventId])
  @@index([category])
}

// ============================================
// DISCUSSIONS & COMMENTS
// ============================================

model Comment {
  id            String   @id @default(cuid())
  
  // Content
  content       String   @db.Text
  
  // Author
  authorId      String
  
  // Parent comment for threading (null = top-level comment)
  parentId      String?
  
  // Entity this comment belongs to (only one should be set)
  bandId        String?
  proposalId    String?
  projectId     String?
  taskId        String?
  
  // Metadata
  isEdited      Boolean  @default(false)
  editedAt      DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  author        User     @relation("CommentsAuthored", fields: [authorId], references: [id])
  parent        Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies       Comment[] @relation("CommentReplies")
  band          Band?    @relation(fields: [bandId], references: [id], onDelete: Cascade)
  proposal      Proposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  project       Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  task          Task?    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  reactions     Reaction[]
  mentions      Mention[]

  @@index([authorId])
  @@index([parentId])
  @@index([bandId])
  @@index([proposalId])
  @@index([projectId])
  @@index([taskId])
  @@index([createdAt])
}

enum ReactionType {
  THUMBS_UP
  THUMBS_DOWN
  HEART
  CELEBRATE
  THINKING
}

model Reaction {
  id            String   @id @default(cuid())
  
  type          ReactionType
  
  // Who reacted
  userId        String
  
  // What they reacted to
  commentId     String
  
  createdAt     DateTime @default(now())

  // Relations
  user          User     @relation("ReactionsGiven", fields: [userId], references: [id], onDelete: Cascade)
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId, type])
  @@index([commentId])
  @@index([userId])
}

model Mention {
  id            String   @id @default(cuid())
  
  // Who was mentioned
  userId        String
  
  // In which comment
  commentId     String
  
  // Has the user seen this mention?
  isRead        Boolean  @default(false)
  readAt        DateTime?
  
  createdAt     DateTime @default(now())

  // Relations
  user          User     @relation("MentionsReceived", fields: [userId], references: [id], onDelete: Cascade)
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@index([userId, isRead])
  @@index([commentId])
}

// ============================================
// PENDING INVITES (for non-registered users)
// ============================================

model PendingInvite {
  id          String   @id @default(cuid())
  email       String
  bandId      String
  invitedById String
  role        MemberRole @default(VOTING_MEMBER)
  token       String   @unique
  expiresAt   DateTime
  notes       String?  @db.Text

  createdAt   DateTime @default(now())

  band        Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  invitedBy   User     @relation("PendingInvitesCreated", fields: [invitedById], references: [id])

  @@unique([email, bandId])
  @@index([email])
  @@index([bandId])
  @@index([token])
  @@index([expiresAt])
}

// ============================================
// AUDIT LOG
// ============================================

model AuditLog {
  id          String   @id @default(cuid())

  // Context - which band (null for non-band entities)
  bandId      String?

  // What happened
  action      String   // "created", "updated", "deleted"
  entityType  String   // "Band", "Task", "Proposal", etc.
  entityId    String   // ID of the affected record
  entityName  String?  // Human-readable name (e.g., task name, proposal title)

  // Who did it
  actorId     String?  // User ID (null if system action)
  actorType   String   @default("user") // "user", "system"

  // What changed (for updates)
  changes     Json?    // { "status": { "from": "TODO", "to": "DONE" } }

  // Request context
  ipAddress   String?
  userAgent   String?

  createdAt   DateTime @default(now())

  // Integrity Guard flags
  flagged       Boolean  @default(false)
  flagReasons   String[] // ["legality_block", "values_mismatch", "scope_mismatch"]
  flagDetails   Json?    // Detailed AI explanations

  // Relations
  band        Band?    @relation(fields: [bandId], references: [id], onDelete: Cascade)

  @@index([bandId, createdAt])
  @@index([entityType, entityId])
  @@index([actorId])
  @@index([createdAt])
}

// ============================================
// AI USAGE TRACKING
// ============================================

model AIUsage {
  id          String   @id @default(cuid())

  // Context
  bandId      String?
  userId      String?
  entityType  String   // "proposal", "project", "task", "checklist"
  entityId    String?

  // Operation
  operation   String   // "proposal_draft", "proposal_validation", etc.

  // Token Metrics
  inputTokens  Int
  outputTokens Int
  totalTokens  Int

  // Environmental Impact (calculated)
  co2Grams        Float
  waterMl         Float
  electricityWh   Float
  ledMinutes      Float

  // Model Info
  model       String   // e.g., "claude-sonnet-4-20250514"

  // Timing
  durationMs  Int

  // Metadata
  promptHash  String?  // Optional hash for tracking prompt versions
  success     Boolean  @default(true)
  error       String?

  createdAt   DateTime @default(now())

  // Relations
  band        Band?    @relation(fields: [bandId], references: [id], onDelete: SetNull)

  @@index([bandId, createdAt])
  @@index([entityType, entityId])
  @@index([operation])
  @@index([createdAt])
}