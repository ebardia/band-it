generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  
  // Location
  zipcode   String?
  
  // Profile - Development & Skills
  strengths        String[]
  weaknesses       String[]
  passions         String[]
  developmentPath  String[]
  
  // Email Verification
  emailVerified    Boolean  @default(false)
  emailVerifiedAt  DateTime?
  verificationToken String?  @unique

  // Password Reset
  passwordResetToken   String?   @unique
  passwordResetExpires DateTime?
  
  // Payment
  stripeCustomerId      String?  @unique
  stripeSubscriptionId  String?  @unique
  subscriptionStatus    SubscriptionStatus @default(INCOMPLETE)
  subscriptionStartedAt DateTime?
  
  // Profile Completion
  profileCompleted Boolean @default(false)

  // Community Guidelines Acceptance
  guidelinesAcceptedAt DateTime?
  guidelinesVersion    Int?

  // Terms of Service & Privacy Policy Acceptance
  tosAcceptedAt DateTime?
  tosVersion    Int?

  // Platform Admin
  isAdmin Boolean @default(false)

  // Moderation Status
  warningCount     Int       @default(0)
  suspendedUntil   DateTime?
  suspensionReason String?
  bannedAt         DateTime?
  banReason        String?

  // Notification Settings
  emailNotificationFrequency EmailFrequency @default(DAILY)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  memberships             Member[]
  sessions                Session[]
  bandsCreated            Band[] @relation("BandCreator")
  notifications           Notification[]
  notificationPreferences NotificationPreference[]
  proposalsCreated        Proposal[] @relation("ProposalCreator")
  votes                   Vote[]
  projectsCreated         Project[] @relation("ProjectCreator")
  projectsLed             Project[] @relation("ProjectLead")
  tasksCreated            Task[] @relation("TaskCreator")
  tasksAssigned           Task[] @relation("TaskAssignee")
  tasksVerified           Task[] @relation("TaskVerifier")
  filesUploaded           File[] @relation("FilesUploaded")

  commentsAuthored        Comment[] @relation("CommentsAuthored")
  reactionsGiven          Reaction[] @relation("ReactionsGiven")
  mentionsReceived        Mention[] @relation("MentionsReceived")
  checklistItemsCompleted ChecklistItem[] @relation("ChecklistItemsCompleted")
  checklistItemsAssigned  ChecklistItem[] @relation("ChecklistItemsAssigned")
  pendingInvitesCreated   PendingInvite[] @relation("PendingInvitesCreated")
  bandsAsBillingOwner     Band[] @relation("BandBillingOwner")
  bandsDissolvedBy        Band[] @relation("BandDissolver")
  eventsCreated           Event[] @relation("EventsCreated")
  eventRSVPs              EventRSVP[] @relation("EventRSVPs")
  eventAttendances        EventAttendance[] @relation("EventAttendances")
  attendanceMarked        EventAttendance[] @relation("AttendanceMarker")
  warnings                Warning[] @relation("WarningsReceived")
  warningsIssued          Warning[] @relation("WarningsIssued")
  blockedTermsCreated     BlockedTerm[] @relation("BlockedTermsCreated")
  flaggedContentAuthored  FlaggedContent[] @relation("FlaggedContentAuthor")
  flaggedContentReviewed  FlaggedContent[] @relation("FlaggedContentReviewer")
  flaggedContentAppealReviewed FlaggedContent[] @relation("FlaggedContentAppealReviewer")
  bandMemberBillings      BandMemberBilling[]

  // Discussions
  channelsCreated         Channel[] @relation("ChannelsCreated")
  messagesAuthored        Message[] @relation("MessagesAuthored")
  messageEdits            MessageEdit[] @relation("MessageEdits")
  channelReadStatuses     ChannelReadStatus[] @relation("ChannelReadStatuses")
  messageMentions         MessageMention[] @relation("MessageMentionsReceived")
  messageReactions        MessageReaction[] @relation("MessageReactionsGiven")

  // Manual Payments
  manualPaymentsAsMember      ManualPayment[] @relation("ManualPaymentMember")
  manualPaymentsInitiated     ManualPayment[] @relation("ManualPaymentInitiator")
  manualPaymentsConfirmed     ManualPayment[] @relation("ManualPaymentConfirmer")
  manualPaymentsDisputed      ManualPayment[] @relation("ManualPaymentDisputer")
  manualPaymentsResolved      ManualPayment[] @relation("ManualPaymentResolver")

  // Help
  helpInteractions            HelpInteraction[]

  // Proposal Reviews
  proposalsReviewed           Proposal[] @relation("ProposalReviewer")
  proposalReviewHistory       ProposalReviewHistory[]
}

enum SubscriptionStatus {
  INCOMPLETE
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
}

enum EmailFrequency {
  REAL_TIME
  HOURLY
  DAILY
  WEEKLY
  NEVER
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  refreshToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================
// MODERATION
// ============================================

model Warning {
  id          String   @id @default(cuid())
  userId      String
  issuedById  String

  reason      String   @db.Text

  // Whether the user has acknowledged seeing this warning
  acknowledged   Boolean  @default(false)
  acknowledgedAt DateTime?

  createdAt   DateTime @default(now())

  // Relations
  user        User     @relation("WarningsReceived", fields: [userId], references: [id], onDelete: Cascade)
  issuedBy    User     @relation("WarningsIssued", fields: [issuedById], references: [id])

  @@index([userId])
  @@index([issuedById])
  @@index([createdAt])
}

model BlockedTerm {
  id          String   @id @default(cuid())
  term        String   @unique  // The blocked word or phrase
  isRegex     Boolean  @default(false)  // Whether to treat as regex pattern
  severity    BlockedTermSeverity @default(WARN)
  category    String?  // Optional category (profanity, spam, etc.)
  isActive    Boolean  @default(true)

  // Metadata
  reason            String?  // Human-readable explanation (e.g., "Hate speech targeting ethnicity")
  confidence        MatchConfidence @default(HIGH)  // Expected match confidence
  userAppealAllowed Boolean @default(true)  // Whether users can appeal content flagged by this term

  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  createdBy   User     @relation("BlockedTermsCreated", fields: [createdById], references: [id])

  @@index([term])
  @@index([isActive])
  @@index([severity])
  @@index([confidence])
}

enum BlockedTermSeverity {
  WARN    // Just flag for review, allow posting
  BLOCK   // Prevent posting entirely
}

enum MatchConfidence {
  HIGH    // Exact match or high-precision regex - auto-action safe
  MEDIUM  // Regex that may have false positives - always review
  LOW     // Broad pattern - flag only with multiple matches
}

model FlaggedContent {
  id            String   @id @default(cuid())

  // What type of content was flagged
  contentType   FlaggedContentType
  contentId     String   // ID of the proposal/comment/task
  contentText   String   @db.Text  // Snapshot of the flagged text

  // Who created the content
  authorId      String

  // What terms matched
  matchedTerms  String[] // Array of matched term strings
  categories    String[] // Categories of matched terms

  // Match metadata
  confidence    MatchConfidence @default(HIGH)  // Inherited from matched term
  canAppeal     Boolean @default(true)  // Whether user can appeal (based on term settings)

  // Status
  status        FlaggedContentStatus @default(PENDING)
  reviewedById  String?
  reviewedAt    DateTime?
  reviewNotes   String?

  // Action taken
  actionTaken   FlaggedContentAction?

  // User appeal
  appealStatus      AppealStatus @default(NONE)
  appealReason      String?  @db.Text  // User's explanation
  appealedAt        DateTime?
  appealReviewedById String?
  appealReviewedAt  DateTime?
  appealReviewNotes String?

  createdAt     DateTime @default(now())

  // Relations
  author        User     @relation("FlaggedContentAuthor", fields: [authorId], references: [id])
  reviewedBy    User?    @relation("FlaggedContentReviewer", fields: [reviewedById], references: [id])
  appealReviewedBy User? @relation("FlaggedContentAppealReviewer", fields: [appealReviewedById], references: [id])

  @@index([contentType])
  @@index([status])
  @@index([authorId])
  @@index([createdAt])
  @@index([appealStatus])
}

enum FlaggedContentType {
  PROPOSAL
  COMMENT
  TASK
}

enum FlaggedContentStatus {
  PENDING   // Awaiting review
  APPROVED  // Reviewed and approved (false positive)
  REMOVED   // Content was removed
  WARNED    // User was warned
}

enum FlaggedContentAction {
  DISMISS       // False positive, no action needed
  REMOVE        // Remove the content
  WARN_USER     // Issue warning to user
  SUSPEND_USER  // Suspend the user
  BAN_USER      // Ban the user
}

enum AppealStatus {
  NONE      // No appeal submitted
  PENDING   // Appeal awaiting review
  APPROVED  // Appeal approved, action reversed
  DENIED    // Appeal denied
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id              String   @id @default(cuid())
  userId          String
  type            NotificationType
  title           String
  message         String?
  actionUrl       String?
  priority        NotificationPriority @default(MEDIUM)
  isRead          Boolean  @default(false)
  isArchived      Boolean  @default(false)
  emailedAt       DateTime?
  readAt          DateTime?
  archivedAt      DateTime?
  
  metadata        Json?
  
  relatedId       String?
  relatedType     String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@index([userId, type])
  @@index([emailedAt])
}

enum NotificationType {
  // Band invitations
  BAND_INVITE_RECEIVED
  BAND_INVITE_ACCEPTED
  BAND_INVITE_DECLINED

  // Band applications
  BAND_APPLICATION_RECEIVED
  BAND_APPLICATION_APPROVED
  BAND_APPLICATION_REJECTED

  // Band membership
  BAND_MEMBER_JOINED
  BAND_MEMBER_LEFT
  BAND_STATUS_CHANGED
  BAND_DISSOLVED

  // Band updates
  BAND_DETAILS_UPDATED

  // Proposals
  PROPOSAL_CREATED
  PROPOSAL_VOTE_NEEDED
  PROPOSAL_APPROVED
  PROPOSAL_REJECTED
  PROPOSAL_CLOSED

  // Projects
  PROJECT_CREATED
  PROJECT_STATUS_CHANGED

  // Tasks
  TASK_CREATED
  TASK_ASSIGNED
  TASK_STATUS_CHANGED
  TASK_COMPLETED
  TASK_VERIFICATION_NEEDED
  TASK_VERIFIED
  TASK_REJECTED

  // Billing
  BILLING_PAYMENT_REQUIRED
  BILLING_PAYMENT_SUCCEEDED
  BILLING_PAYMENT_FAILED
  BILLING_GRACE_PERIOD_WARNING
  BILLING_BAND_DEACTIVATED
  BILLING_OWNER_LEFT
  BILLING_OWNER_CLAIMED
  BILLING_SUBSCRIPTION_UPGRADED
  BILLING_SUBSCRIPTION_DOWNGRADED

  // Manual Payments
  MANUAL_PAYMENT_RECORDED
  MANUAL_PAYMENT_CONFIRMED
  MANUAL_PAYMENT_DISPUTED
  MANUAL_PAYMENT_RESOLVED
  MANUAL_PAYMENT_AUTO_CONFIRM_WARNING

  // Events
  EVENT_CREATED
  EVENT_UPDATED
  EVENT_CANCELLED
  EVENT_REMINDER
  EVENT_RSVP_RECEIVED
  EVENT_ATTENDANCE_MARKED

  // Moderation
  MODERATION_WARNING
  MODERATION_SUSPENSION
  MODERATION_BAN
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model NotificationTemplate {
  id              String @id @default(cuid())
  type            NotificationType @unique
  title           String
  message         String
  emailSubject    String
  emailBody       String
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model NotificationPreference {
  id              String @id @default(cuid())
  userId          String
  type            NotificationType
  inApp           Boolean @default(true)
  email           Boolean @default(true)
  
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, type])
  @@index([userId])
}

// ============================================
// BAND
// ============================================

model Band {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique

  // Core Information
  description String @db.Text
  mission     String @db.Text
  values      String[]

  // Location
  zipcode     String?

  // Matching
  skillsLookingFor     String[]
  whatMembersWillLearn String[]

  // Visual
  imageUrl    String?

  // Status
  status      BandStatus @default(INACTIVE)

  // Activation & Dissolution
  activatedAt       DateTime?   // Set when band first reaches 3 members
  dissolvedAt       DateTime?   // Set when band is dissolved
  dissolvedById     String?     // User who dissolved the band
  dissolutionReason String?     // Optional reason for dissolution

  // Billing
  billingOwnerId        String?
  stripeCustomerId      String?   @unique
  stripeSubscriptionId  String?   @unique
  stripePriceId         String?
  billingStatus         BillingStatus @default(NONE)
  billingCycleStart     DateTime?
  paymentFailedAt       DateTime?
  gracePeriodEndsAt     DateTime?

  // Membership Configuration
  membershipRequirements String @db.Text
  whoCanApprove         MemberRole[]

  // Voting Configuration
  votingMethod          VotingMethod @default(SIMPLE_MAJORITY)
  votingPeriodDays      Int @default(7)
  quorumPercentage      Int @default(50) // Minimum % of eligible voters that must participate
  whoCanCreateProposals MemberRole[] @default([FOUNDER, GOVERNOR, MODERATOR, CONDUCTOR])

  // Role Management Configuration
  whoCanChangeRoles     MemberRole[] @default([FOUNDER])

  // Proposal Review Configuration
  requireProposalReview Boolean @default(false)  // If true, proposals need moderator approval before voting

  // Metadata
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  createdBy User @relation("BandCreator", fields: [createdById], references: [id])
  billingOwner User? @relation("BandBillingOwner", fields: [billingOwnerId], references: [id])
  dissolvedBy User? @relation("BandDissolver", fields: [dissolvedById], references: [id])
  members   Member[]
  proposals Proposal[]
  projects  Project[]
  tasks     Task[]
  events    Event[]
  files     File[]
  comments  Comment[]
  auditLogs AuditLog[]
  pendingInvites PendingInvite[]
  aiUsage   AIUsage[]
  buckets   Bucket[]
  financeSettings BandFinanceSettings?
  stripeAccounts BandStripeAccount[]
  duesPlans BandDuesPlan[]
  memberBillings BandMemberBilling[]
  channels  Channel[]
  manualPayments ManualPayment[]

  @@index([createdById])
  @@index([status])
  @@index([billingOwnerId])
  @@index([billingStatus])
}

enum BandStatus {
  PENDING    // DEPRECATED - do not use, kept for migration compatibility
  ACTIVE
  INACTIVE
}

enum BillingStatus {
  NONE           // No payment needed yet (< 3 members)
  PENDING        // 3 members reached, awaiting first payment
  ACTIVE         // Subscription active
  PAST_DUE       // Payment failed, in grace period
  INACTIVE       // Grace period expired or subscription cancelled
}

enum VotingMethod {
  SIMPLE_MAJORITY      // >50%
  SUPERMAJORITY_66     // >66%
  SUPERMAJORITY_75     // >75%
  UNANIMOUS            // 100%
}

model Member {
  id        String   @id @default(cuid())
  userId    String
  bandId    String
  role          MemberRole
  requestedRole MemberRole?  // Role requested during application
  status        MemberStatus @default(PENDING)

  // Finance role
  isTreasurer Boolean @default(false)

  invitedBy String?
  notes     String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  band Band @relation(fields: [bandId], references: [id], onDelete: Cascade)
  manualPayments ManualPayment[]

  @@unique([userId, bandId])
  @@index([bandId])
  @@index([userId])
  @@index([status])
}

enum MemberRole {
  FOUNDER
  GOVERNOR
  MODERATOR
  CONDUCTOR
  VOTING_MEMBER
  OBSERVER
}

enum MemberStatus {
  INVITED
  PENDING
  ACTIVE
  REJECTED
}

// ============================================
// DISCUSSIONS - CHANNELS & MESSAGES
// ============================================

enum ChannelVisibility {
  PUBLIC      // All band members can access
  MODERATOR   // Moderators, Governors, Founders only
  GOVERNANCE  // Governors, Founders only
}

enum MessageModerationStatus {
  PENDING   // Awaiting moderation
  APPROVED  // Passed moderation
  FLAGGED   // Flagged for review
  REMOVED   // Removed by moderator
}

model Channel {
  id          String   @id @default(cuid())
  bandId      String
  name        String   @db.VarChar(80)
  slug        String   @db.VarChar(100)
  description String?  @db.VarChar(500)
  visibility  ChannelVisibility @default(PUBLIC)
  isDefault   Boolean  @default(false)
  isArchived  Boolean  @default(false)

  // Denormalized for performance
  lastMessageAt DateTime?
  messageCount  Int      @default(0)

  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  band        Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("ChannelsCreated", fields: [createdById], references: [id])
  messages    Message[]
  readStatuses ChannelReadStatus[]

  @@unique([bandId, slug])
  @@index([bandId, isArchived])
  @@index([bandId, visibility])
  @@index([bandId, lastMessageAt])
}

model Message {
  id          String   @id @default(cuid())
  channelId   String
  authorId    String
  threadId    String?  // If reply, points to parent message ID (must be top-level)

  content     String   @db.Text  // 1-10000 characters
  isPinned    Boolean  @default(false)
  isEdited    Boolean  @default(false)
  editedAt    DateTime?

  moderationStatus MessageModerationStatus @default(PENDING)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?  // Soft delete

  // Relations
  channel     Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
  author      User     @relation("MessagesAuthored", fields: [authorId], references: [id])
  parentMessage Message? @relation("MessageReplies", fields: [threadId], references: [id])
  replies     Message[] @relation("MessageReplies")
  edits       MessageEdit[]
  mentions    MessageMention[]
  reactions   MessageReaction[]

  @@index([channelId, createdAt])
  @@index([channelId, isPinned])
  @@index([channelId, deletedAt, createdAt])
  @@index([channelId, moderationStatus])
  @@index([threadId])
  @@index([authorId])
}

model MessageEdit {
  id              String   @id @default(cuid())
  messageId       String
  previousContent String   @db.Text
  editedById      String
  editedAt        DateTime @default(now())

  // Relations
  message         Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  editedBy        User     @relation("MessageEdits", fields: [editedById], references: [id])

  @@index([messageId])
}

model ChannelReadStatus {
  id                String   @id @default(cuid())
  channelId         String
  userId            String
  lastReadAt        DateTime @default(now())
  lastReadMessageId String?

  // Relations
  channel           Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user              User     @relation("ChannelReadStatuses", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, userId])
  @@index([userId])
}

model MessageMention {
  id          String   @id @default(cuid())
  messageId   String
  userId      String?              // User mention (null if role mention)
  roleMention String?              // 'governors'|'moderators'|'conductors'|'everyone'|'channel'
  createdAt   DateTime @default(now())

  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user        User?    @relation("MessageMentionsReceived", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

model MessageReaction {
  id          String   @id @default(cuid())
  messageId   String
  userId      String
  emoji       String   @db.VarChar(32)
  createdAt   DateTime @default(now())

  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user        User     @relation("MessageReactionsGiven", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])  // One reaction per user per message
  @@index([messageId])
  @@index([userId])
}

// ============================================
// FINANCE - BUCKETS & SETTINGS
// ============================================

model Bucket {
  id        String   @id @default(cuid())
  bandId    String
  name      String   @db.VarChar(64)
  type      BucketType
  visibility BucketVisibility @default(MEMBERS)
  isActive  Boolean  @default(true)

  // Audit trail - which proposal created this bucket
  createdByProposalId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  band      Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdByProposal Proposal? @relation("BucketCreatedByProposal", fields: [createdByProposalId], references: [id])

  @@unique([bandId, name])
  @@index([bandId])
  @@index([type])
  @@index([isActive])
}

enum BucketType {
  OPERATING     // Day-to-day operational funds
  PROJECT       // Funds allocated to specific projects
  RESTRICTED    // Funds with specific usage restrictions
  UNRESTRICTED  // General purpose funds
  COMMITMENT    // Funds committed for future obligations
}

enum BucketVisibility {
  OFFICERS_ONLY  // Only officers can see this bucket
  MEMBERS        // All members can see this bucket
}

model BandFinanceSettings {
  id        String   @id @default(cuid())
  bandId    String   @unique

  bucketManagementPolicy BucketManagementPolicy @default(TREASURER_ONLY)

  // Dues Enforcement
  duesEnforcementEnabled Boolean @default(true)
  newMemberGraceDays     Int     @default(7)   // Days after approval before enforcement
  lapsedMemberGraceDays  Int     @default(3)   // Days after payment failure before enforcement

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  band      Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
}

enum BucketManagementPolicy {
  TREASURER_ONLY  // Only treasurers can manage buckets
  OFFICER_TIER    // Officers (Conductor, Moderator, Governor, Founder) can manage
}

model BandStripeAccount {
  id               String    @id @default(uuid())
  bandId           String
  stripeAccountId  String

  // Account status from Stripe
  chargesEnabled   Boolean   @default(false)
  detailsSubmitted Boolean   @default(false)

  // Timestamps
  connectedAt      DateTime
  disconnectedAt   DateTime?  // Soft delete - null means active

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  band             Band      @relation(fields: [bandId], references: [id], onDelete: Cascade)

  // Only one ACTIVE connection per band (disconnectedAt is null)
  // Multiple historical records allowed (disconnectedAt is set)
  @@index([bandId])
  @@index([stripeAccountId])
  @@index([disconnectedAt])
}

// ============================================
// FINANCE - BAND DUES
// ============================================

model BandDuesPlan {
  id              String   @id @default(uuid())
  bandId          String
  isActive        Boolean  @default(true)

  // Pricing
  currency        String   @default("usd")
  amountCents     Int      // Minimum 50 (~$0.50 Stripe minimum)
  interval        String   // 'month' | 'year'

  // Stripe IDs (on the connected account)
  stripeProductId String?
  stripePriceId   String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  band            Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)

  @@index([bandId])
  @@index([isActive])
}

model BandMemberBilling {
  id                    String    @id @default(uuid())
  bandId                String
  memberUserId          String

  // Billing status
  status                BandMemberBillingStatus @default(UNPAID)
  currentPeriodEnd      DateTime?

  // Stripe IDs (on the connected account)
  stripeCustomerId      String?
  stripeSubscriptionId  String?

  // Tracking
  lastPaymentAt         DateTime?

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  band                  Band      @relation(fields: [bandId], references: [id], onDelete: Cascade)
  user                  User      @relation(fields: [memberUserId], references: [id], onDelete: Cascade)

  @@unique([bandId, memberUserId])
  @@index([bandId, status])
  @@index([stripeSubscriptionId])
}

enum BandMemberBillingStatus {
  UNPAID     // Default, no active subscription
  ACTIVE     // Subscription exists and current period not ended
  PAST_DUE   // Stripe reports subscription delinquent / payment failed
  CANCELED   // Subscription ended
}

// ============================================
// FINANCE - MANUAL PAYMENTS
// ============================================

model ManualPayment {
  id                  String   @id @default(cuid())
  bandId              String
  memberId            String   // The member who paid (Member.id)
  memberUserId        String   // The user who paid (for easier lookups)

  amount              Int      // Amount in cents
  currency            String   @default("usd")
  paymentMethod       PaymentMethod
  paymentMethodOther  String?  // If method is OTHER
  paymentDate         DateTime
  note                String?  @db.Text

  initiatedById       String   // User who created the record
  initiatedByRole     InitiatedByRole // TREASURER or MEMBER
  initiatedAt         DateTime @default(now())

  status              ManualPaymentStatus @default(PENDING)

  confirmedById       String?
  confirmedAt         DateTime?

  disputedById        String?
  disputedAt          DateTime?
  disputeReason       String?  @db.Text

  resolvedById        String?
  resolvedAt          DateTime?
  resolutionNote      String?  @db.Text
  resolutionOutcome   ResolutionOutcome?

  autoConfirmAt       DateTime? // 7 days from initiation
  autoConfirmWarned   Boolean  @default(false) // Track if 2-day warning sent

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  band                Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  member              Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)
  memberUser          User     @relation("ManualPaymentMember", fields: [memberUserId], references: [id])
  initiatedBy         User     @relation("ManualPaymentInitiator", fields: [initiatedById], references: [id])
  confirmedBy         User?    @relation("ManualPaymentConfirmer", fields: [confirmedById], references: [id])
  disputedBy          User?    @relation("ManualPaymentDisputer", fields: [disputedById], references: [id])
  resolvedBy          User?    @relation("ManualPaymentResolver", fields: [resolvedById], references: [id])
  files               File[]

  @@index([bandId, status])
  @@index([memberId, status])
  @@index([memberUserId])
  @@index([autoConfirmAt])
}

enum PaymentMethod {
  ZELLE
  VENMO
  CASHAPP
  CASH
  CHECK
  OTHER
}

enum InitiatedByRole {
  TREASURER
  MEMBER
}

enum ManualPaymentStatus {
  PENDING
  CONFIRMED
  DISPUTED
  REJECTED
  AUTO_CONFIRMED
}

enum ResolutionOutcome {
  CONFIRMED
  REJECTED
}

model StripeEventReceipt {
  id                String    @id @default(uuid())
  bandId            String?
  stripeAccountId   String
  stripeEventId     String    @unique
  eventType         String

  // Processing status
  receivedAt        DateTime  @default(now())
  processedAt       DateTime?
  processingStatus  StripeEventProcessingStatus
  errorMessage      String?   @db.Text

  @@index([stripeAccountId])
  @@index([stripeEventId])
  @@index([eventType])
}

enum StripeEventProcessingStatus {
  OK
  IGNORED
  ERROR
}

// ============================================
// PROPOSALS
// ============================================

model Proposal {
  id            String   @id @default(cuid())
  bandId        String
  createdById   String

  // Core
  title         String
  description   String @db.Text

  // Type & Priority (category - what the proposal is about)
  type          ProposalType @default(GENERAL)
  priority      ProposalPriority @default(MEDIUM)

  // Execution Type (behavior - what happens on approval)
  executionType     ProposalExecutionType @default(PROJECT)
  executionSubtype  String?  // e.g., "FINANCE_BUCKET_GOVERNANCE_V1" for specific validation rules

  // Declarative Effects (for GOVERNANCE and ACTION types)
  effects              Json?     // Array of effect operations to execute on approval
  effectsValidatedAt   DateTime? // When effects were validated
  effectsExecutedAt    DateTime? // When effects were executed
  executionError       String?   @db.Text // Error message if execution failed

  // Problem & Outcome
  problemStatement    String? @db.Text
  expectedOutcome     String? @db.Text
  risksAndConcerns    String? @db.Text

  // Budget
  budgetRequested     Decimal? @db.Decimal(12, 2)
  budgetBreakdown     String? @db.Text
  fundingSource       String?

  // Timeline
  proposedStartDate   DateTime?
  proposedEndDate     DateTime?
  milestones          String? @db.Text

  // Attachments & Links (legacy - keeping for backwards compatibility)
  attachmentUrls      String[]
  externalLinks       String[]

  // Voting
  status        ProposalStatus @default(OPEN)
  votingEndsAt  DateTime?
  votingStartedAt DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  closedAt      DateTime?

  // Review (for bands with requireProposalReview enabled)
  submittedAt       DateTime?       // When submitted for review
  reviewedById      String?         // User ID of reviewer
  reviewedAt        DateTime?       // When reviewed
  rejectionReason   String? @db.Text  // If rejected by reviewer, why
  submissionCount   Int @default(0) // Track resubmissions (max 3)

  // AI
  aiValidation  Json?

  // Relations
  band          Band @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdBy     User @relation("ProposalCreator", fields: [createdById], references: [id])
  reviewedBy    User? @relation("ProposalReviewer", fields: [reviewedById], references: [id])
  votes         Vote[]
  projects      Project[]
  files         File[]
  comments      Comment[]
  executionLogs ProposalExecutionLog[]
  bucketsCreated Bucket[] @relation("BucketCreatedByProposal")
  reviewHistory ProposalReviewHistory[]

  @@index([bandId])
  @@index([createdById])
  @@index([status])
  @@index([votingEndsAt])
  @@index([type])
  @@index([executionType])
}

enum ProposalType {
  GENERAL
  BUDGET
  PROJECT
  POLICY
  MEMBERSHIP
}

// What happens when a proposal is approved
enum ProposalExecutionType {
  GOVERNANCE   // Auto-executes effects that change band rules/settings
  PROJECT      // Creates a project (existing behavior)
  ACTION       // Auto-executes effects that trigger routine tasks
  RESOLUTION   // Just records the decision, nothing executes
}

enum ProposalExecutionStatus {
  SUCCESS
  FAILED
}

model ProposalExecutionLog {
  id                String   @id @default(cuid())
  proposalId        String
  bandId            String

  // What was executed
  executionSubtype  String   // e.g., "FINANCE_BUCKET_GOVERNANCE_V1"
  effectsSubmitted  Json     // What was requested
  effectsExecuted   Json     // What actually ran

  // Result
  status            ProposalExecutionStatus
  errorMessage      String?  @db.Text

  executedAt        DateTime @default(now())

  // Relations
  proposal          Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)

  @@index([proposalId])
  @@index([bandId])
  @@index([executedAt])
}

// Track history of proposal reviews (for audit trail)
model ProposalReviewHistory {
  id          String   @id @default(cuid())
  proposalId  String
  reviewerId  String
  action      ProposalReviewAction
  reason      String?  @db.Text
  createdAt   DateTime @default(now())

  // Relations
  proposal    Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  reviewer    User     @relation(fields: [reviewerId], references: [id])

  @@index([proposalId])
  @@index([reviewerId])
}

enum ProposalPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ProposalStatus {
  DRAFT           // Author is still editing, not submitted
  PENDING_REVIEW  // Submitted, waiting for moderator review
  OPEN            // Approved by reviewer (or review not required), open for voting
  CLOSED          // Voting ended without reaching threshold
  APPROVED        // Passed
  REJECTED        // Failed vote OR rejected by reviewer
  WITHDRAWN       // Author withdrew from review
}

enum ProposalReviewAction {
  APPROVED
  REJECTED
}

model Vote {
  id          String   @id @default(cuid())
  proposalId  String
  userId      String
  
  vote        VoteType
  comment     String? @db.Text
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  proposal Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([proposalId, userId])
  @@index([proposalId])
  @@index([userId])
}

enum VoteType {
  YES
  NO
  ABSTAIN
}

// ============================================
// PROJECTS
// ============================================

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum ProjectPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model Project {
  id          String   @id @default(cuid())
  bandId      String
  proposalId  String
  
  // Core
  name        String
  description String?  @db.Text
  status      ProjectStatus @default(PLANNING)
  priority    ProjectPriority @default(MEDIUM)
  
  // Timeline
  startDate   DateTime?
  targetDate  DateTime?
  completedAt DateTime?
  
  // Budget & Effort
  estimatedBudget Decimal? @db.Decimal(12, 2)
  estimatedHours  Int?
  
  // Deliverables & Success
  deliverables    String?  @db.Text
  successCriteria String?  @db.Text
  
  // Organization
  tags            String[]
  orderIndex      Int      @default(0)
  
  // Dependencies (stored as comma-separated project IDs for simplicity)
  dependsOn       String[]
  
  // Progress tracking
  totalTasks      Int @default(0)
  completedTasks  Int @default(0)
  
  // AI
  aiGenerated     Boolean @default(false)
  aiValidation    Json?
  
  // Assignment
  leadId          String?
  
  // Metadata
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  band      Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  proposal  Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  createdBy User     @relation("ProjectCreator", fields: [createdById], references: [id])
  lead      User?    @relation("ProjectLead", fields: [leadId], references: [id])
  tasks     Task[]
  files     File[]
  comments  Comment[]

  @@index([bandId])
  @@index([proposalId])
  @@index([status])
  @@index([priority])
  @@index([createdById])
  @@index([leadId])
}

// ============================================
// TASKS
// ============================================

enum TaskStatus {
  TODO
  IN_PROGRESS
  IN_REVIEW
  COMPLETED
  BLOCKED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum AssigneeType {
  MEMBER
  BANDINO
  VENDOR
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model Task {
  id          String   @id @default(cuid())
  projectId   String
  bandId      String
  
  // Core
  name        String
  description String?  @db.Text
  status      TaskStatus @default(TODO)
  priority    TaskPriority @default(MEDIUM)
  
  // Assignment
  assigneeId    String?
  assigneeType  AssigneeType @default(MEMBER)
  
  // Timeline
  dueDate     DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  
  // Effort
  estimatedHours Int?
  actualHours    Int?
  estimatedCost  Decimal? @db.Decimal(12, 2)
  actualCost     Decimal? @db.Decimal(12, 2)
  
  // Verification
  requiresVerification Boolean @default(true)
  verificationStatus   VerificationStatus?
  verifiedById         String?
  verifiedAt           DateTime?
  verificationNotes    String? @db.Text
  
  // Proof/Evidence (legacy - keeping for backwards compatibility)
  attachments      String[]
  proofDescription String? @db.Text
  receiptUrls      String[]
  
  // Organization
  tags        String[]
  orderIndex  Int @default(0)
  
  // AI
  aiGenerated   Boolean @default(false)
  aiValidation  Json?
  
  // Metadata
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  project    Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  band       Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdBy  User     @relation("TaskCreator", fields: [createdById], references: [id])
  assignee   User?    @relation("TaskAssignee", fields: [assigneeId], references: [id])
  verifiedBy User?    @relation("TaskVerifier", fields: [verifiedById], references: [id])
  files      File[]
  comments  Comment[]
  checklistItems ChecklistItem[]

  @@index([projectId])
  @@index([bandId])
  @@index([status])
  @@index([priority])
  @@index([assigneeId])
  @@index([createdById])
  @@index([verifiedById])
  @@index([dueDate])
}

// ============================================
// EVENTS
// ============================================

enum EventType {
  ONLINE_MEETING
  IN_PERSON_MEETING
  SOCIAL
  HYBRID
}

enum RSVPStatus {
  GOING
  NOT_GOING
  MAYBE
}

model Event {
  id          String   @id @default(cuid())
  bandId      String
  createdById String

  // Core
  title       String
  description String?  @db.Text
  eventType   EventType

  // Timing
  startTime   DateTime
  endTime     DateTime
  timezone    String   @default("America/New_York")

  // Location (for IN_PERSON_MEETING, SOCIAL, HYBRID)
  location    String?
  address     String?  @db.Text

  // Online meeting (for ONLINE_MEETING, HYBRID)
  meetingUrl  String?
  meetingId   String?
  meetingPassword String?

  // Recurrence (using RRULE format from iCalendar RFC 5545)
  // null = one-time event
  // Example: "FREQ=WEEKLY;BYDAY=MO,WE,FR" or "FREQ=MONTHLY;BYMONTHDAY=15"
  recurrenceRule String?

  // For recurring events, track the series end date (optional)
  recurrenceEndDate DateTime?

  // For exceptions/modifications to recurring events
  // If this is set, this event is an exception to the series
  parentEventId String?
  exceptionDate DateTime?  // The date this exception replaces in the series

  // Cancellation
  isCancelled     Boolean  @default(false)
  cancelledAt     DateTime?
  cancellationNote String?

  // Notes from event (added after meeting)
  meetingNotes    String?  @db.Text

  // Reminders (hours before event)
  reminderHours   Int[]    @default([24, 1])
  lastReminderSentAt DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  band        Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("EventsCreated", fields: [createdById], references: [id])
  parentEvent Event?   @relation("EventExceptions", fields: [parentEventId], references: [id])
  exceptions  Event[]  @relation("EventExceptions")
  rsvps       EventRSVP[]
  attendance  EventAttendance[]
  files       File[]

  @@index([bandId])
  @@index([createdById])
  @@index([startTime])
  @@index([eventType])
  @@index([parentEventId])
  @@index([isCancelled])
}

model EventRSVP {
  id          String   @id @default(cuid())
  eventId     String
  userId      String

  status      RSVPStatus
  note        String?  @db.Text

  // For recurring events, RSVP applies to the series
  // If user needs different response for specific instance, use EventAttendance

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation("EventRSVPs", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
}

model EventAttendance {
  id          String   @id @default(cuid())
  eventId     String
  userId      String

  // For recurring events, track which occurrence this is for
  occurrenceDate DateTime?

  // Attendance status
  attended    Boolean
  arrivedAt   DateTime?
  leftAt      DateTime?

  // Notes about attendance
  notes       String?  @db.Text

  // Who marked attendance (could be the user themselves or a moderator)
  markedById  String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation("EventAttendances", fields: [userId], references: [id], onDelete: Cascade)
  markedBy    User     @relation("AttendanceMarker", fields: [markedById], references: [id])

  @@unique([eventId, userId, occurrenceDate])
  @@index([eventId])
  @@index([userId])
  @@index([occurrenceDate])
  @@index([markedById])
}

// ============================================
// CHECKLIST ITEMS
// ============================================

model ChecklistItem {
  id          String   @id @default(cuid())
  taskId      String
  
  // Content
  description String
  notes       String?  @db.Text
  
  // Assignment
  assigneeId  String?
  dueDate     DateTime?
  
  // Status
  isCompleted   Boolean  @default(false)
  completedById String?
  completedAt   DateTime?
  
  // Order
  orderIndex    Int @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  completedBy User?    @relation("ChecklistItemsCompleted", fields: [completedById], references: [id])
  assignee    User?    @relation("ChecklistItemsAssigned", fields: [assigneeId], references: [id])
  files       File[]

  @@index([taskId])
  @@index([completedById])
  @@index([assigneeId])
}

// ============================================
// FILES
// ============================================

enum FileCategory {
  IMAGE
  DOCUMENT
  RECEIPT
  OTHER
}

model File {
  id            String   @id @default(cuid())
  
  // File info
  filename      String
  originalName  String
  mimeType      String
  size          Int
  category      FileCategory @default(OTHER)
  
  // Storage
  storageKey    String   @unique
  url           String
  
  // Ownership
  uploadedById  String
  
  // Attachments - which entity this file belongs to (only one should be set)
  bandId          String?
  proposalId      String?
  projectId       String?
  taskId          String?
  checklistItemId String?
  eventId         String?
  manualPaymentId String?

  // Metadata
  description   String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  uploadedBy    User     @relation("FilesUploaded", fields: [uploadedById], references: [id])
  band          Band?    @relation(fields: [bandId], references: [id], onDelete: Cascade)
  proposal      Proposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  project       Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  task          Task?    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  checklistItem ChecklistItem? @relation(fields: [checklistItemId], references: [id], onDelete: Cascade)
  event         Event?   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  manualPayment ManualPayment? @relation(fields: [manualPaymentId], references: [id], onDelete: Cascade)

  @@index([uploadedById])
  @@index([bandId])
  @@index([proposalId])
  @@index([projectId])
  @@index([taskId])
  @@index([checklistItemId])
  @@index([eventId])
  @@index([manualPaymentId])
  @@index([category])
}

// ============================================
// DISCUSSIONS & COMMENTS
// ============================================

model Comment {
  id            String   @id @default(cuid())
  
  // Content
  content       String   @db.Text
  
  // Author
  authorId      String
  
  // Parent comment for threading (null = top-level comment)
  parentId      String?
  
  // Entity this comment belongs to (only one should be set)
  bandId        String?
  proposalId    String?
  projectId     String?
  taskId        String?
  
  // Metadata
  isEdited      Boolean  @default(false)
  editedAt      DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  // Relations
  author        User     @relation("CommentsAuthored", fields: [authorId], references: [id])
  parent        Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies       Comment[] @relation("CommentReplies")
  band          Band?    @relation(fields: [bandId], references: [id], onDelete: Cascade)
  proposal      Proposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  project       Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  task          Task?    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  reactions     Reaction[]
  mentions      Mention[]

  @@index([authorId])
  @@index([parentId])
  @@index([bandId])
  @@index([proposalId])
  @@index([projectId])
  @@index([taskId])
  @@index([createdAt])
}

enum ReactionType {
  THUMBS_UP
  THUMBS_DOWN
  HEART
  CELEBRATE
  THINKING
}

model Reaction {
  id            String   @id @default(cuid())
  
  type          ReactionType
  
  // Who reacted
  userId        String
  
  // What they reacted to
  commentId     String
  
  createdAt     DateTime @default(now())

  // Relations
  user          User     @relation("ReactionsGiven", fields: [userId], references: [id], onDelete: Cascade)
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId, type])
  @@index([commentId])
  @@index([userId])
}

model Mention {
  id            String   @id @default(cuid())
  
  // Who was mentioned
  userId        String
  
  // In which comment
  commentId     String
  
  // Has the user seen this mention?
  isRead        Boolean  @default(false)
  readAt        DateTime?
  
  createdAt     DateTime @default(now())

  // Relations
  user          User     @relation("MentionsReceived", fields: [userId], references: [id], onDelete: Cascade)
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@index([userId, isRead])
  @@index([commentId])
}

// ============================================
// PENDING INVITES (for non-registered users)
// ============================================

model PendingInvite {
  id          String   @id @default(cuid())
  email       String
  bandId      String
  invitedById String
  role        MemberRole @default(VOTING_MEMBER)
  token       String   @unique
  expiresAt   DateTime
  notes       String?  @db.Text

  createdAt   DateTime @default(now())

  band        Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  invitedBy   User     @relation("PendingInvitesCreated", fields: [invitedById], references: [id])

  @@unique([email, bandId])
  @@index([email])
  @@index([bandId])
  @@index([token])
  @@index([expiresAt])
}

// ============================================
// AUDIT LOG
// ============================================

model AuditLog {
  id          String   @id @default(cuid())

  // Context - which band (null for non-band entities)
  bandId      String?

  // What happened
  action      String   // "created", "updated", "deleted"
  entityType  String   // "Band", "Task", "Proposal", etc.
  entityId    String   // ID of the affected record
  entityName  String?  // Human-readable name (e.g., task name, proposal title)

  // Who did it
  actorId     String?  // User ID (null if system action)
  actorType   String   @default("user") // "user", "system"
  actorName   String?  // User's name at time of action
  actorMemberSince DateTime? // When the user joined this band (for context)

  // What changed (for updates)
  changes     Json?    // { "status": { "from": "TODO", "to": "DONE" } }

  // Request context
  ipAddress   String?
  userAgent   String?

  createdAt   DateTime @default(now())

  // Integrity Guard flags
  flagged       Boolean  @default(false)
  flagReasons   String[] // ["legality_block", "values_mismatch", "scope_mismatch"]
  flagDetails   Json?    // Detailed AI explanations

  // Relations
  band        Band?    @relation(fields: [bandId], references: [id], onDelete: Cascade)

  @@index([bandId, createdAt])
  @@index([entityType, entityId])
  @@index([actorId])
  @@index([createdAt])
}

// ============================================
// AI USAGE TRACKING
// ============================================

model AIUsage {
  id          String   @id @default(cuid())

  // Context
  bandId      String?
  userId      String?
  entityType  String   // "proposal", "project", "task", "checklist"
  entityId    String?

  // Operation
  operation   String   // "proposal_draft", "proposal_validation", etc.

  // Token Metrics
  inputTokens  Int
  outputTokens Int
  totalTokens  Int

  // Environmental Impact (calculated)
  co2Grams        Float
  waterMl         Float
  electricityWh   Float
  ledMinutes      Float

  // Model Info
  model       String   // e.g., "claude-sonnet-4-20250514"

  // Timing
  durationMs  Int

  // Metadata
  promptHash  String?  // Optional hash for tracking prompt versions
  success     Boolean  @default(true)
  error       String?

  createdAt   DateTime @default(now())

  // Relations
  band        Band?    @relation(fields: [bandId], references: [id], onDelete: SetNull)

  @@index([bandId, createdAt])
  @@index([entityType, entityId])
  @@index([operation])
  @@index([createdAt])
}

// ============================================
// ADMIN TASKS (Routine Administrative Actions)
// ============================================

model AdminTaskDefinition {
  id            String   @id @default(cuid())

  // Task identification
  taskType      String   @unique  // e.g., "EXPORT_MEMBER_ROSTER", "EXPORT_AUDIT_LOG", "SEND_ANNOUNCEMENT"
  name          String             // Human-readable name
  description   String   @db.Text  // What this task does

  // UI Configuration
  icon          String?            // Icon name for the UI
  category      String   @default("general")  // For grouping in UI

  // Permissions - which roles can execute this task
  allowedRoles  MemberRole[]

  // Parameters schema (JSON Schema format for validation)
  parametersSchema  Json?

  // Status
  isActive      Boolean  @default(true)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  executions    AdminTaskExecution[]

  @@index([isActive])
  @@index([category])
}

enum AdminTaskExecutionStatus {
  PENDING     // Task is queued
  RUNNING     // Task is currently executing
  COMPLETED   // Task finished successfully
  FAILED      // Task failed
}

model AdminTaskExecution {
  id              String   @id @default(cuid())

  // What task was executed
  taskDefinitionId String
  taskType        String   // Denormalized for easier queries

  // Context
  bandId          String
  executedById    String   // Who triggered the task

  // Parameters used for this execution
  parameters      Json?

  // Execution status
  status          AdminTaskExecutionStatus @default(PENDING)

  // Result
  resultSummary   String?  @db.Text  // Human-readable summary of what happened
  resultData      Json?              // Structured result data (e.g., file URL, email count)
  errorMessage    String?  @db.Text  // If failed, what went wrong

  // For file exports - store the file info
  outputFileUrl   String?
  outputFileName  String?
  outputFileSize  Int?

  // Timing
  startedAt       DateTime?
  completedAt     DateTime?

  createdAt       DateTime @default(now())

  // Relations
  taskDefinition  AdminTaskDefinition @relation(fields: [taskDefinitionId], references: [id])

  @@index([bandId, createdAt])
  @@index([taskDefinitionId])
  @@index([executedById])
  @@index([status])
  @@index([taskType])
}

// ==========================================
// HELP SYSTEM
// ==========================================

model FaqEntry {
  id              String   @id @default(cuid())
  question        String
  answer          String   @db.Text
  category        String   // GETTING_STARTED, BANDS, PROPOSALS, DISCUSSIONS, BILLING, ACCOUNT
  keywords        String[]
  relatedPages    String[]
  sortOrder       Int      @default(0)
  isPublished     Boolean  @default(true)
  viewCount       Int      @default(0)
  helpfulCount    Int      @default(0)
  notHelpfulCount Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  interactions    HelpInteraction[]

  @@index([category])
  @@index([isPublished])
}

model AiHelpCache {
  id                  String   @id @default(cuid())
  questionHash        String   @unique
  questionNormalized  String
  questionOriginal    String
  answer              String   @db.Text
  category            String?
  hitCount            Int      @default(1)
  lastUsedAt          DateTime @default(now())
  createdAt           DateTime @default(now())
  expiresAt           DateTime

  interactions        HelpInteraction[]

  @@index([questionHash])
  @@index([expiresAt])
}

model HelpInteraction {
  id            String    @id @default(cuid())
  userId        String
  question      String
  source        String    // FAQ, CACHE, AI, RATE_LIMITED
  faqEntryId    String?
  cacheEntryId  String?
  answer        String    @db.Text
  currentPage   String?
  wasHelpful    Boolean?
  createdAt     DateTime  @default(now())

  user          User      @relation(fields: [userId], references: [id])
  faqEntry      FaqEntry? @relation(fields: [faqEntryId], references: [id])
  cacheEntry    AiHelpCache? @relation(fields: [cacheEntryId], references: [id])

  @@index([userId, createdAt])
  @@index([source])
}

model HelpRateLimit {
  id              String   @id @default(cuid())
  userId          String
  date            String   // YYYY-MM-DD format
  aiRequestCount  Int      @default(0)

  @@unique([userId, date])
}